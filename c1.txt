# -*- coding: utf-8 -*-
"""Finallab_CYK and PCYK.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SO427nuYEn7sClIzXUBc0qdSFh_Y0Zq1

# **CYK**

S -> NP VP,
PP -> P NP,
VP -> V NP,
VP -> VP PP,
NP -> NP PP,
NP -> astronomers,
NP -> ears,
NP -> saw,
V -> saw,
NP -> telescope,
NP -> stars,
P -> with.

**If grammar given in qp, text file la potrunga**
"""

from collections import defaultdict
from nltk.tree import Tree
from tabulate import tabulate

# ---------------------------
# READ GRAMMAR FROM FILE
# Format: A -> B C OR A -> word
# ---------------------------
def read_grammar(filename):
    grammar = defaultdict(list)
    rhs_to_lhs = defaultdict(set)
    with open(filename) as f:
        for line in f:
            if '->' not in line:
                continue
            lhs, rhs = line.strip().split('->')
            lhs = lhs.strip()
            rhs_symbols = rhs.strip().split()
            grammar[lhs].append(rhs_symbols)
            rhs_to_lhs[tuple(rhs_symbols)].add(lhs)
    return grammar, rhs_to_lhs

# ---------------------------
# CYK PARSER WITH BACKPOINTERS
# ---------------------------
def cyk_parser(tokens, rhs_to_lhs):
    n = len(tokens)
    table = [[set() for _ in range(n)] for _ in range(n)]
    back = [[defaultdict(list) for _ in range(n)] for _ in range(n)]

    # Fill diagonals
    for i, token in enumerate(tokens):
        for lhs in rhs_to_lhs.get((token,), []):
            table[i][i].add(lhs)
            print(f"Matched terminal: {lhs}[1,{i+1}] -> {token}")

    # Fill upper triangle
    for l in range(2, n + 1):  # Span length
        for i in range(n - l + 1):  # Start index
            j = i + l - 1
            for k in range(i, j):
                for B in table[i][k]:
                    for C in table[k+1][j]:
                        for A in rhs_to_lhs.get((B, C), []):
                            table[i][j].add(A)
                            back[i][j][A].append((k, B, C))
                            print(f"Applied Rule: {A}[{l},{i+1}] --> {B}[{k-i+1},{i+1}] {C}[{j-k},{k+2}]")

    # Tree building
    def build_tree(i, j, symbol):
        if i == j:
            return (symbol, tokens[i])
        for k, B, C in back[i][j].get(symbol, []):
            left = build_tree(i, k, B)
            right = build_tree(k+1, j, C)
            return (symbol, left, right)

    return table, back, build_tree if 'S' in table[0][n-1] else None

# ---------------------------
# CONVERT TO nltk.Tree FOR DISPLAY
# ---------------------------
def tuple_to_nltk_tree(tree_tuple):
    if isinstance(tree_tuple, tuple):
        label = tree_tuple[0]
        children = [tuple_to_nltk_tree(child) for child in tree_tuple[1:]]
        return Tree(label, children)
    else:
        return tree_tuple

# ---------------------------
# PRINT CYK TABLE USING TABULATE
# ---------------------------
def print_table(table, tokens):
    n = len(tokens)
    display_table = [["" for _ in range(n)] for _ in range(n)]
    for i in range(n):
        for j in range(i, n):
            if table[i][j]:
                display_table[i][j] = ", ".join(sorted(table[i][j]))
    headers = [f"{i+1}:{w}" for i, w in enumerate(tokens)]
    print("\nCYK Parse Table:\n")
    print(tabulate(display_table, headers=headers, tablefmt="grid"))

# ---------------------------
# MAIN
# ---------------------------
if __name__ == "__main__":
    grammar_file = "/content/cyk_grammar.txt"  # Replace with your file path
    sentence = "astronomers saw stars with ears"
    tokens = sentence.split()

    grammar, rhs_to_lhs = read_grammar(grammar_file)
    table, back, tree_builder = cyk_parser(tokens, rhs_to_lhs)

    if tree_builder:
        tree_tuple = tree_builder(0, len(tokens)-1, 'S')
        print("\n✔ Sentence is valid.\n")
        nltk_tree = tuple_to_nltk_tree(tree_tuple)
        nltk_tree.pretty_print()
    else:
        print("\n✘ Sentence is invalid according to the grammar.\n")

    print_table(table,tokens)

"""# **PCYK**

trees kudutha, idhu pola give tree and work
"""

from collections import defaultdict
import math
import pprint
from prettytable import PrettyTable

# Step 1: Hardcoded parse trees from the image
tree1 = ['S',
           ['NP', 'John'],
           ['VP',
               ['VP', ['V', 'called'], ['NP', 'Mary']],
               ['PP', ['P', 'from'], ['NP', 'Denver']]
           ]
        ]

tree2 = ['S',
           ['NP', 'John'],
           ['VP',
               ['V', 'called'],
               ['NP',
                   ['NP', 'Mary'],
                   ['PP', ['P', 'from'], ['NP', 'Denver']]
               ]
           ]
        ]

# Step 2: Extract productions
def extract_productions(tree, productions):
    if isinstance(tree, list):
        lhs = tree[0]
        rhs = []

        for child in tree[1:]:
            if isinstance(child, list):
                rhs.append(child[0])
                extract_productions(child, productions)
            else:
                rhs.append(child)
        rule = (lhs, tuple(rhs))
        productions[rule] += 1

productions = defaultdict(int)
extract_productions(tree1, productions)
extract_productions(tree2, productions)

# Step 3: Compute PCFG
lhs_counts = defaultdict(int)
for (lhs, rhs), count in productions.items():
    lhs_counts[lhs] += count

pcfg = defaultdict(list)
for (lhs, rhs), count in productions.items():
    prob = count / lhs_counts[lhs]
    pcfg[lhs].append((rhs, prob))

print("\n--- PCFG ---")
for lhs, rules in pcfg.items():
    for rhs, prob in rules:
        print(f"{lhs} -> {' '.join(rhs)} [{prob:.2f}]")


# Step 4: Viterbi parser for new sentence
sentence = ['John', 'called', 'Mary', 'from', 'Denver']
n = len(sentence)
table = [[defaultdict(lambda: (-math.inf, None)) for _ in range(n)] for _ in range(n)]

# Step 5: Initialize terminals
for i, word in enumerate(sentence):
    for lhs, rules in pcfg.items():
        for rhs, prob in rules:
            if len(rhs) == 1 and rhs[0] == word:
                table[i][i][lhs] = (math.log(prob), word)

# Step 6: CKY-style Viterbi algorithm
for span in range(2, n+1):
    for i in range(n - span + 1):
        j = i + span - 1
        for k in range(i, j):
            for lhs, rules in pcfg.items():
                for rhs, prob in rules:
                    if len(rhs) == 2:
                        B, C = rhs
                        if B in table[i][k] and C in table[k+1][j]:
                            prob_B, back_B = table[i][k][B]
                            prob_C, back_C = table[k+1][j][C]
                            total_prob = math.log(prob) + prob_B + prob_C
                            if total_prob > table[i][j][lhs][0]:
                                table[i][j][lhs] = (total_prob, (k, B, C))

# Step 7: Backtrack to recover tree
def build_tree(i, j, symbol):
    prob, back = table[i][j].get(symbol, (-math.inf, None))

    # Terminal rule: back is a string (the word)
    if isinstance(back, str):
        return [symbol, back]

    # Unary case fallback (not expected here, but safe)
    if back is None:
        return [symbol]

    # Binary rule: back = (k, B, C)
    k, B, C = back
    left = build_tree(i, k, B)
    right = build_tree(k+1, j, C)
    return [symbol, left, right]

# Final output
print("\n--- Most Probable Parse Tree ---")
if 'S' in table[0][n-1]:
    tree = build_tree(0, n-1, 'S')
    pprint.pprint(tree)

    print(f"\nProbability of the parse tree: {math.exp(table[0][n-1]['S'][0]):.8f}")

    print("\n--- Viterbi Parsing Table (Triangular Format) ---\n")

    pretty_table = []

    for row in range(n):
        current_row = []
        for col in range(n):
            if col < row:
                current_row.append("")  # lower triangle blank
            else:
                cell = table[row][col]
                if not cell:
                    current_row.append("-")
                else:
                    entries = []
                    for symbol, (prob, back) in sorted(cell.items(), key=lambda x: -x[1][0]):
                        prob_val = math.exp(prob)
                        if isinstance(back, str):
                            entries.append(f"{symbol}({prob_val:.2f})")
                        else:
                            entries.append(f"{symbol}({prob_val:.6f})")
                    current_row.append("\n".join(entries))
        pretty_table.append(current_row)

    # Create header row
    headers = [""] + sentence
    cyk = PrettyTable()
    cyk.field_names = headers
    for i, row in enumerate(pretty_table):
        cyk.add_row([sentence[i]] + row)

    print(cyk)

else:
    print("No valid parse found.")

# IF YOU HAVE 5-6 TREES IN QUESTION PAPER, DO LIKE THIS
#LOOP
# trees = [
#     ['S',
#         ['NP', 'John'],
#         ['VP',
#             ['VP', ['V', 'called'], ['NP', 'Mary']],
#             ['PP', ['P', 'from'], ['NP', 'Denver']]
#         ]
#     ],
#     ['S',
#         ['NP', 'John'],
#         ['VP',
#             ['V', 'called'],
#             ['NP',
#                 ['NP', 'Mary'],
#                 ['PP', ['P', 'from'], ['NP', 'Denver']]
#             ]
#         ]
#     ],
#     # Add 4 more trees here:
#     tree3,
#     tree4,
#     tree5,
#     tree6,
# ]

# CHANGE IN THIS PART

# productions = defaultdict(int)

# for tree in trees:
#     extract_productions(tree, productions)


# #TO CHECK PRODUCTIONS
# print("\n--- Production Counts ---")
# for (lhs, rhs), count in productions.items():
#     print(f"{lhs} -> {' '.join(rhs)} : {count}")